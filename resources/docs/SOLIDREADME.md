# CIDM-4390: 2020SP SOFTWARE SYS DEVEL

## SOLID Agile Development

### Single Responsibility Principle: 
*  This principle is all about cohesion, which is a measure of how closely related two things are, and consequently whether they belong together. I've always liked the way Uncle Bob described it: "A class should have one, and only one, reason to change." Achieving this principle is difficult, but the benefits are huge, because when you need to make a change to a behavior, you can always identify just the right place to make it. Also, because each class does only one thing, you can feel confident that you won't accidentally change some other behavior.
### Open/Closed Principle:
*  This principle was originally described by Bertrand Meyer in his book "Object-Oriented Software Construction" (Prentice Hall PTR, 1997), and it can be confusing. I prefer to describe it in a simplified way: "You should be able to extend or change the behavior of a class without changing the class itself." While you probably don't want to apply a principle like this to every behavior in a class, you should be mindful of reasonable places that consuming code may want to change the behavior. To achieve this, you need to introduce abstractions and leverage polymorphism. The result will make it easier for derived classes to extend the behavior in response to new requirements.
### Liskov Substitution Principle:
*  This principle is one I've seen many developers get wrong. In essence, it says that if you create a derived class, you should be able to provide it to anything that consumes the base class, and it should still work. This principle is closely related to the Open/Closed Principle, as in object-oriented languages the primary means of extending a class is by deriving from it. Without this rule, all clients who consume classes in an inheritance hierarchy have to know about every derived class, which is clearly bad from a maintenance perspective. When I talk to developers about this, I often say: "You don't inherit from another class to reuse some code it has. You inherit because it is the other class, but with some changes."
### Interface Segregation Principle:
*  The essence of this principle is twofold: Many fine-grained interfaces are good, and interfaces should be designed for their clients. It's important to note that this isn't only applicable to Microsoft .NET Framework interfaces, but should be thought of more broadly and applied to the public interface of a class. Like the other SOLID principles, this one is related to the others in that it asserts each interface should have a single responsibility and not be overloaded. Also, you should be careful about inheritance for your interfaces: Just because two interfaces happen to share some methods, it doesn't follow that one inherits from another, or even from a common base. Think about it this way: "Clients shouldn't be forced to depend on interfaces they don't use."
### Dependency Inversion Principle:
*  Dependency inversion isn't just the last one on the list, it's also the one that brings them all together for the win. It's very natural to create layers of components where higher layers depend on lower layers. This principle challenges that assumption, and holds that higher-level things should depend on abstractions, and not on the lower-level things themselves. Uncle Bob likes to say, "Depend on abstractions. Do not depend on concretions." Creating malleable, maintainable code requires finding the right abstractions and using them as the code upon which you depend. These abstractions become the "seams" where you can change the code in response to new or changing requirements.